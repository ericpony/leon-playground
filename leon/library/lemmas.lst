SortedListSpec {
  /* l1 ~ l2 implies sort(l1) == sort(l2) */
  def sort_permutation_prop (l1: List[BigInt], l2: List[BigInt])

  /* sort(list) == sort(sort(list)) */
  def sort_idempotent_prop (list: List[BigInt])

  /* sort(l1 ++ l2) == sort(l2 ++ l1) */
  def sort_commutative_prop (l1: List[BigInt], l2: List[BigInt])

  /* sort(sort(l1 ++ l2) ++ l3) == sort(l1 ++ sort(l2 ++ l3)) */
  def sort_associative_prop (l1 : List[BigInt], l2 : List[BigInt], l3 : List[BigInt])
}

PermutationSpec {
  /* l1 ~ l2 implies [l1] == [l2] */
  def permutation_content (l1 : List[BigInt], l2 : List[BigInt]) 

  /* l1 ~ l2 implies ll ++ l1 ~ ll ++ l2 */
  def permutation_concat (l1 : List[BigInt], l2 : List[BigInt], ll : List[BigInt])

  /* l1 ++ l2 ~ l2 ++ l1 */
 def permutation_concat_comm (l1 : List[BigInt], l2 : List[BigInt])
}

DeleteSpec {
  /* list - a - b == list - b - a */
  def delete_comm (list : List[BigInt], a : BigInt, b : BigInt)

  /* (l1 - e) ++ l2 == (l1 ++ l2) - e */
  def delete_concat (l1 : List[BigInt], l2 : List[BigInt], e : BigInt)

  /* [list] == [list - e] + [e] */
  def delete_content (list : List[BigInt], e : BigInt)

  /* either list contains m, or list - m == list */
  def delete_not_contains (list: List[BigInt], m: BigInt)

  /* list contains a and a != b implies list - b contains a */
  def delete_contains (list : List[BigInt], a : BigInt, b : BigInt)
}

MinSpec {
}

DistinctSpec {
}

